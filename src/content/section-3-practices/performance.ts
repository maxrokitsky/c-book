import type { Chapter } from '../types'

export default {
  id: 'performance',
  title: 'Производительность',
  description: 'Профилирование, оптимизация и понимание производительности кода на C',
  blocks: [
    {
      type: 'prose',
      markdown: `# Производительность

C выбирают за производительность, но быстрый язык не означает автоматически быстрый код. Оптимизация — это целенаправленный процесс: сначала **измерение**, затем **анализ**, и только потом **изменение**.

Главное правило: **не оптимизируйте без профилировщика**. Программисты систематически ошибаются в предположениях о том, что именно тормозит.`,
    },
    {
      type: 'prose',
      markdown: `## Уровни оптимизации компилятора

Первый шаг — использовать оптимизации компилятора:

| Флаг | Описание |
|------|----------|
| \`-O0\` | Без оптимизаций (по умолчанию, для отладки) |
| \`-O1\` | Базовые оптимизации |
| \`-O2\` | Рекомендуемый уровень для продакшена |
| \`-O3\` | Агрессивные оптимизации (может увеличить размер кода) |
| \`-Os\` | Оптимизация размера кода |
| \`-Ofast\` | \`-O3\` + нарушение стандартов (быстрая, но неточная математика) |

Для большинства проектов \`-O2\` — оптимальный выбор.`,
    },
    {
      type: 'prose',
      markdown: `## Профилирование с gprof и perf

Прежде чем оптимизировать, нужно **измерить**. Два основных инструмента:`,
    },
    {
      type: 'code',
      language: 'bash',
      code: `# === gprof ===
# Компиляция с профилировочной информацией
gcc -pg -O2 -o myapp src/*.c

# Запуск (генерирует gmon.out)
./myapp

# Анализ
gprof myapp gmon.out > profile.txt

# === perf ===
# Запись данных профилирования
perf record -g ./myapp

# Анализ
perf report

# Статистика выполнения
perf stat ./myapp`,
      filename: 'profiling.sh',
    },
    {
      type: 'output',
      content: `  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 45.20      1.42     1.42   100000     0.00     0.00  matrix_multiply
 23.10      2.15     0.73  1000000     0.00     0.00  vector_dot
 15.40      2.63     0.48    50000     0.00     0.00  sort_array
  8.90      2.91     0.28   200000     0.00     0.00  hash_lookup
  7.40      3.14     0.23        1     0.23     3.14  main`,
      prompt: '$ gprof myapp gmon.out | head -10',
    },
    {
      type: 'prose',
      markdown: `## Кеш-дружелюбный код

Современные процессоры тратят больше времени на ожидание данных из памяти, чем на вычисления. Расположение данных в памяти критически важно:`,
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>
#include <time.h>

#define N 4096

int matrix[N][N];

/* Медленно: обход по столбцам (cache miss на каждом шаге) */
long sum_column_major(void)
{
    long sum = 0;
    for (int col = 0; col < N; col++)
        for (int row = 0; row < N; row++)
            sum += matrix[row][col];
    return sum;
}

/* Быстро: обход по строкам (последовательный доступ к памяти) */
long sum_row_major(void)
{
    long sum = 0;
    for (int row = 0; row < N; row++)
        for (int col = 0; col < N; col++)
            sum += matrix[row][col];
    return sum;
}`,
      filename: 'cache_friendly.c',
    },
    {
      type: 'note',
      variant: 'tip',
      title: 'Разница может быть огромной',
      markdown: 'На матрице 4096x4096 обход по строкам может быть в **5-10 раз быстрее**, чем по столбцам. Это связано с тем, что при последовательном доступе данные уже находятся в кеш-линии процессора, а при обходе по столбцам каждое обращение вызывает промах кеша (cache miss).',
    },
    {
      type: 'prose',
      markdown: `## Struct of Arrays vs Array of Structs

Для обработки больших массивов данных расположение полей влияет на производительность:`,
    },
    {
      type: 'code',
      language: 'c',
      code: `/* Array of Structs (AoS) — плохо для пакетной обработки одного поля */
typedef struct {
    float x, y, z;
    float vx, vy, vz;
    float mass;
    int id;
} Particle_AoS;

Particle_AoS particles_aos[100000];

/* Struct of Arrays (SoA) — хорошо для SIMD и пакетной обработки */
typedef struct {
    float x[100000];
    float y[100000];
    float z[100000];
    float vx[100000];
    float vy[100000];
    float vz[100000];
    float mass[100000];
    int id[100000];
} Particles_SoA;

Particles_SoA particles_soa;

/* Обновление позиций — SoA эффективнее (данные последовательны) */
void update_positions_soa(Particles_SoA *p, int count, float dt)
{
    for (int i = 0; i < count; i++) {
        p->x[i] += p->vx[i] * dt;
        p->y[i] += p->vy[i] * dt;
        p->z[i] += p->vz[i] * dt;
    }
}`,
      filename: 'soa_vs_aos.c',
    },
    {
      type: 'note',
      variant: 'warning',
      title: 'Преждевременная оптимизация',
      markdown: '«Преждевременная оптимизация — корень всех зол» (Дональд Кнут). Сначала напишите **корректный и читаемый** код, затем профилируйте и оптимизируйте только горячие участки. В 99% случаев алгоритмическая оптимизация (O(n) вместо O(n^2)) даёт больший эффект, чем низкоуровневые трюки.',
    },
    {
      type: 'quiz',
      question: 'Почему обход двумерного массива по строкам быстрее, чем по столбцам?',
      options: [
        'Компилятор лучше оптимизирует циклы по строкам',
        'Массив хранится в памяти построчно, и последовательный доступ использует кеш процессора',
        'Обход по столбцам вызывает больше вызовов функций',
        'Обход по строкам использует меньше регистров',
      ],
      correctIndex: 1,
      explanation:
        'В C двумерный массив хранится в памяти построчно (row-major order). При обходе по строкам доступ к элементам последовательный — кеш-линия процессора загружает сразу несколько элементов. При обходе по столбцам шаг между элементами равен размеру строки, что вызывает промахи кеша.',
    },
    {
      type: 'exercise',
      title: 'Оптимизируйте поиск',
      description:
        'Дан массив из 1 000 000 отсортированных целых чисел. Функция линейного поиска работает слишком медленно. Реализуйте бинарный поиск и объясните, почему он быстрее.',
      hints: [
        'Бинарный поиск имеет сложность O(log n) против O(n) у линейного',
        'Для 1 000 000 элементов: линейный — до 1 000 000 сравнений, бинарный — до 20',
        'Не забудьте про граничные случаи: пустой массив, элемент не найден',
      ],
      solution: `#include <stddef.h>

/**
 * Бинарный поиск в отсортированном массиве.
 * Возвращает индекс найденного элемента или -1.
 *
 * Сложность: O(log n) — для 1 000 000 элементов
 * требуется не более 20 сравнений.
 */
int binary_search(const int *arr, size_t size, int target)
{
    if (!arr || size == 0) return -1;

    size_t lo = 0;
    size_t hi = size;

    while (lo < hi) {
        size_t mid = lo + (hi - lo) / 2;  /* Защита от переполнения */
        if (arr[mid] == target) {
            return (int)mid;
        } else if (arr[mid] < target) {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }

    return -1;
}`,
      solutionLanguage: 'c',
    },
  ],
} satisfies Chapter
