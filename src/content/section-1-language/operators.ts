import type { Chapter } from '../types'

export default {
  id: 'operators',
  title: 'Операторы',
  description: 'Арифметические, логические, побитовые операторы и приоритет',
  blocks: [
    {
      type: 'prose',
      markdown: `# Операторы

Операторы — это символы, выполняющие действия над значениями (операндами). C предоставляет богатый набор операторов: от простой арифметики до работы с отдельными битами.

В этой главе мы рассмотрим основные группы операторов и правила их приоритета.`,
    },
    {
      type: 'prose',
      markdown: `## Арифметические операторы

Основные арифметические операторы работают с числами:

| Оператор | Действие | Пример | Результат |
|----------|----------|--------|-----------|
| \`+\` | Сложение | \`5 + 3\` | \`8\` |
| \`-\` | Вычитание | \`5 - 3\` | \`2\` |
| \`*\` | Умножение | \`5 * 3\` | \`15\` |
| \`/\` | Деление | \`5 / 3\` | \`1\` (целочисленное!) |
| \`%\` | Остаток от деления | \`5 % 3\` | \`2\` |
| \`+\` | Унарный плюс | \`+5\` | \`5\` |
| \`-\` | Унарный минус | \`-5\` | \`-5\` |`,
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>

int main(void)
{
    int a = 17, b = 5;

    printf("%d + %d = %d\\n", a, b, a + b);
    printf("%d - %d = %d\\n", a, b, a - b);
    printf("%d * %d = %d\\n", a, b, a * b);
    printf("%d / %d = %d\\n", a, b, a / b);   // целочисленное деление!
    printf("%d %% %d = %d\\n", a, b, a % b);   // %% для вывода символа %

    // Деление целых чисел отбрасывает дробную часть
    printf("\\n7 / 2 = %d (целочисленное)\\n", 7 / 2);

    // Для дробного результата хотя бы один операнд должен быть float/double
    printf("7.0 / 2 = %.1f (вещественное)\\n", 7.0 / 2);
    printf("7 / 2.0 = %.1f (вещественное)\\n", 7 / 2.0);

    // Приведение типа (cast)
    int x = 7, y = 2;
    printf("(double)7 / 2 = %.1f\\n", (double)x / y);

    return 0;
}`,
      filename: 'arithmetic.c',
    },
    {
      type: 'output',
      content: `17 + 5 = 22
17 - 5 = 12
17 * 5 = 85
17 / 5 = 3
17 % 5 = 2

7 / 2 = 3 (целочисленное)
7.0 / 2 = 3.5 (вещественное)
7 / 2.0 = 3.5 (вещественное)
(double)7 / 2 = 3.5`,
      prompt: '$ gcc arithmetic.c -o arithmetic && ./arithmetic',
    },
    {
      type: 'note',
      variant: 'danger',
      title: 'Целочисленное деление',
      markdown:
        'Одна из самых частых ошибок начинающих: `5 / 3` в C даёт `1`, а не `1.666...`! При делении двух целых чисел результат всегда целый (дробная часть отбрасывается). Чтобы получить дробный результат, хотя бы один операнд должен быть `float` или `double`.',
    },
    {
      type: 'prose',
      markdown: `## Операторы присваивания

Помимо простого присваивания \`=\`, C поддерживает составные операторы:`,
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>

int main(void)
{
    int x = 10;
    printf("Начальное значение: x = %d\\n", x);

    x += 5;    // x = x + 5
    printf("x += 5  ->  x = %d\\n", x);

    x -= 3;    // x = x - 3
    printf("x -= 3  ->  x = %d\\n", x);

    x *= 2;    // x = x * 2
    printf("x *= 2  ->  x = %d\\n", x);

    x /= 4;    // x = x / 4
    printf("x /= 4  ->  x = %d\\n", x);

    x %= 3;    // x = x % 3
    printf("x %%= 3  ->  x = %d\\n", x);

    return 0;
}`,
      filename: 'assignment.c',
    },
    {
      type: 'output',
      content: `Начальное значение: x = 10
x += 5  ->  x = 15
x -= 3  ->  x = 12
x *= 2  ->  x = 24
x /= 4  ->  x = 6
x %= 3  ->  x = 0`,
      prompt: '$ gcc assignment.c -o assignment && ./assignment',
    },
    {
      type: 'prose',
      markdown: `## Инкремент и декремент

Операторы \`++\` и \`--\` увеличивают или уменьшают значение на 1. Они бывают **префиксными** и **постфиксными**:`,
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>

int main(void)
{
    int a = 5;

    // Постфиксный: возвращает текущее значение, ПОТОМ увеличивает
    printf("a++ = %d\\n", a++);  // выведет 5
    printf("a = %d\\n", a);      // a теперь 6

    // Префиксный: СНАЧАЛА увеличивает, потом возвращает
    printf("++a = %d\\n", ++a);  // a стало 7, выведет 7
    printf("a = %d\\n", a);      // a = 7

    // Декремент работает аналогично
    int b = 10;
    printf("\\nb-- = %d\\n", b--);  // выведет 10, b станет 9
    printf("--b = %d\\n", --b);    // b станет 8, выведет 8

    return 0;
}`,
      filename: 'increment.c',
    },
    {
      type: 'output',
      content: `a++ = 5
a = 6
++a = 7
a = 7

b-- = 10
--b = 8`,
      prompt: '$ gcc increment.c -o increment && ./increment',
    },
    {
      type: 'note',
      variant: 'warning',
      title: 'Не злоупотребляйте!',
      markdown:
        'Никогда не используйте `++` или `--` дважды с одной переменной в одном выражении. Выражение вроде `i++ + ++i` — это **неопределённое поведение**. Компилятор может выдать любой результат. Используйте инкремент/декремент как отдельные операторы.',
    },
    {
      type: 'prose',
      markdown: `## Операторы сравнения

Операторы сравнения возвращают \`1\` (истина) или \`0\` (ложь):

| Оператор | Значение | Пример | Результат |
|----------|----------|--------|-----------|
| \`==\` | Равно | \`5 == 5\` | \`1\` |
| \`!=\` | Не равно | \`5 != 3\` | \`1\` |
| \`<\` | Меньше | \`3 < 5\` | \`1\` |
| \`>\` | Больше | \`5 > 3\` | \`1\` |
| \`<=\` | Меньше или равно | \`5 <= 5\` | \`1\` |
| \`>=\` | Больше или равно | \`3 >= 5\` | \`0\` |`,
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>

int main(void)
{
    int x = 10, y = 20;

    printf("x == y: %d\\n", x == y);  // 0
    printf("x != y: %d\\n", x != y);  // 1
    printf("x < y:  %d\\n", x < y);   // 1
    printf("x > y:  %d\\n", x > y);   // 0
    printf("x <= 10: %d\\n", x <= 10); // 1
    printf("x >= 15: %d\\n", x >= 15); // 0

    return 0;
}`,
      filename: 'comparison.c',
    },
    {
      type: 'note',
      variant: 'danger',
      title: '== vs =',
      markdown:
        'Одна из самых коварных ошибок в C: `if (x = 5)` — это не сравнение, а **присваивание**! Переменной `x` присвоится 5, а условие всегда будет истинным (ненулевое значение). Правильно: `if (x == 5)`. Включите предупреждения (`-Wall`), чтобы компилятор помог обнаружить такие ошибки.',
    },
    {
      type: 'prose',
      markdown: `## Логические операторы

Логические операторы работают с логическими значениями (0 — ложь, ненулевое — истина):

| Оператор | Значение | Пример |
|----------|----------|--------|
| \`&&\` | Логическое И | \`(a > 0) && (b > 0)\` |
| \`\\|\\|\` | Логическое ИЛИ | \`(a > 0) \\|\\| (b > 0)\` |
| \`!\` | Логическое НЕ | \`!(a > 0)\` |`,
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>

int main(void)
{
    int age = 25;
    int has_ticket = 1;  // 1 = true
    int is_vip = 0;      // 0 = false

    // && (И): оба условия должны быть истинны
    printf("Пропустить (возраст >= 18 И есть билет): %d\\n",
           (age >= 18) && has_ticket);

    // || (ИЛИ): достаточно одного истинного условия
    printf("Пропустить (есть билет ИЛИ VIP): %d\\n",
           has_ticket || is_vip);

    // ! (НЕ): инвертирует значение
    printf("Не VIP: %d\\n", !is_vip);

    // Комбинация
    printf("(возраст >= 18) && (билет || VIP): %d\\n",
           (age >= 18) && (has_ticket || is_vip));

    return 0;
}`,
      filename: 'logical.c',
    },
    {
      type: 'note',
      variant: 'info',
      title: 'Короткое замыкание (short-circuit evaluation)',
      markdown: `Логические операторы в C используют **ленивое вычисление**:
- \`&&\`: если левый операнд ложен (0), правый **не вычисляется**
- \`||\`: если левый операнд истинен (не 0), правый **не вычисляется**

Это важно, когда правый операнд имеет побочные эффекты. Например: \`if (ptr != NULL && *ptr > 0)\` — безопасно, потому что \`*ptr\` не вычисляется, если \`ptr\` равен \`NULL\`.`,
    },
    {
      type: 'prose',
      markdown: `## Побитовые операторы

Побитовые операторы работают с отдельными битами числа:

| Оператор | Значение | Пример |
|----------|----------|--------|
| \`&\` | Побитовое И | \`0b1010 & 0b1100\` = \`0b1000\` |
| \`\\|\` | Побитовое ИЛИ | \`0b1010 \\| 0b1100\` = \`0b1110\` |
| \`^\` | Побитовое Исключающее ИЛИ | \`0b1010 ^ 0b1100\` = \`0b0110\` |
| \`~\` | Побитовое НЕ (инверсия) | \`~0b1010\` = \`...0101\` |
| \`<<\` | Сдвиг влево | \`0b0001 << 3\` = \`0b1000\` |
| \`>>\` | Сдвиг вправо | \`0b1000 >> 2\` = \`0b0010\` |`,
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>

// Вспомогательная функция для вывода числа в двоичном виде
void print_binary(unsigned char n)
{
    for (int i = 7; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
    }
}

int main(void)
{
    unsigned char a = 0b10101010;  // 170
    unsigned char b = 0b11001100;  // 204

    printf("a       = "); print_binary(a); printf(" (%d)\\n", a);
    printf("b       = "); print_binary(b); printf(" (%d)\\n", b);
    printf("a & b   = "); print_binary(a & b); printf(" (%d)\\n", a & b);
    printf("a | b   = "); print_binary(a | b); printf(" (%d)\\n", a | b);
    printf("a ^ b   = "); print_binary(a ^ b); printf(" (%d)\\n", a ^ b);
    printf("~a      = "); print_binary(~a); printf(" (%d)\\n", (unsigned char)~a);

    // Сдвиги
    unsigned char x = 1;
    printf("\\n1 << 0 = "); print_binary(x); printf(" (%d)\\n", x);
    printf("1 << 1 = "); print_binary(x << 1); printf(" (%d)\\n", x << 1);
    printf("1 << 4 = "); print_binary(x << 4); printf(" (%d)\\n", x << 4);
    printf("1 << 7 = "); print_binary(x << 7); printf(" (%d)\\n", x << 7);

    return 0;
}`,
      filename: 'bitwise.c',
    },
    {
      type: 'output',
      content: `a       = 10101010 (170)
b       = 11001100 (204)
a & b   = 10001000 (136)
a | b   = 11101110 (238)
a ^ b   = 01100110 (102)
~a      = 01010101 (85)

1 << 0 = 00000001 (1)
1 << 1 = 00000010 (2)
1 << 4 = 00010000 (16)
1 << 7 = 10000000 (128)`,
      prompt: '$ gcc bitwise.c -o bitwise && ./bitwise',
    },
    {
      type: 'diagram',
      component: 'BitRepresentation',
      props: {
        examples: [
          { label: 'a', value: 170, bits: '10101010' },
          { label: 'b', value: 204, bits: '11001100' },
          { label: 'a & b', value: 136, bits: '10001000' },
          { label: 'a | b', value: 238, bits: '11101110' },
          { label: 'a ^ b', value: 102, bits: '01100110' },
        ],
      },
      caption: 'Визуализация побитовых операций И, ИЛИ, Исключающее ИЛИ.',
    },
    {
      type: 'prose',
      markdown: `## Тернарный оператор

Тернарный оператор \`?\` \`:\` — единственный оператор в C с тремя операндами. Это краткая форма условия:

\`\`\`
результат = условие ? значение_если_истина : значение_если_ложь;
\`\`\``,
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>

int main(void)
{
    int age = 20;
    const char *status = (age >= 18) ? "совершеннолетний" : "несовершеннолетний";
    printf("Статус: %s\\n", status);

    int a = 15, b = 23;
    int max = (a > b) ? a : b;
    printf("Максимум из %d и %d: %d\\n", a, b, max);

    // Абсолютное значение
    int x = -42;
    int abs_x = (x >= 0) ? x : -x;
    printf("|%d| = %d\\n", x, abs_x);

    return 0;
}`,
      filename: 'ternary.c',
    },
    {
      type: 'prose',
      markdown: `## Приоритет операторов

Приоритет определяет порядок выполнения операторов в выражении (от высшего к низшему):

| Приоритет | Операторы | Ассоциативность |
|-----------|----------|-----------------|
| 1 (высший) | \`()\` \`[]\` \`.\` \`->\` \`++\`(пост) \`--\`(пост) | Слева направо |
| 2 | \`++\`(пре) \`--\`(пре) \`!\` \`~\` \`+\`(ун.) \`-\`(ун.) \`*\`(разым.) \`&\`(адрес) \`sizeof\` | **Справа налево** |
| 3 | \`*\` \`/\` \`%\` | Слева направо |
| 4 | \`+\` \`-\` | Слева направо |
| 5 | \`<<\` \`>>\` | Слева направо |
| 6 | \`<\` \`<=\` \`>\` \`>=\` | Слева направо |
| 7 | \`==\` \`!=\` | Слева направо |
| 8 | \`&\` (побитовое И) | Слева направо |
| 9 | \`^\` (побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ) | Слева направо |
| 10 | \`\\|\` (побитовое ИЛИ) | Слева направо |
| 11 | \`&&\` | Слева направо |
| 12 | \`\\|\\|\` | Слева направо |
| 13 | \`?:\` (тернарный) | **Справа налево** |
| 14 | \`=\` \`+=\` \`-=\` и т.д. | **Справа налево** |
| 15 (низший) | \`,\` (запятая) | Слева направо |`,
    },
    {
      type: 'note',
      variant: 'tip',
      title: 'Золотое правило',
      markdown:
        'Если вы сомневаетесь в приоритете — **используйте скобки**. Выражение `(a + b) * c` яснее, чем полагаться на знание того, что `*` имеет больший приоритет, чем `+`. Читаемость кода важнее краткости.',
    },
    {
      type: 'code',
      language: 'c',
      code: `#include <stdio.h>

int main(void)
{
    // Приоритет: * выше +
    printf("2 + 3 * 4 = %d\\n", 2 + 3 * 4);      // 14, не 20
    printf("(2 + 3) * 4 = %d\\n", (2 + 3) * 4);    // 20

    // Частая ошибка: & ниже ==
    int flags = 0b1010;
    // НЕПРАВИЛЬНО: flags & 0b0010 == 0  ->  flags & (0b0010 == 0)  ->  flags & 0
    // ПРАВИЛЬНО:  (flags & 0b0010) == 0
    printf("flags & 2 == 0: %d\\n", flags & 2 == 0);     // неожиданный результат!
    printf("(flags & 2) == 0: %d\\n", (flags & 2) == 0);  // правильно: 0

    return 0;
}`,
      filename: 'precedence.c',
    },
    {
      type: 'output',
      content: `2 + 3 * 4 = 14
(2 + 3) * 4 = 20
flags & 2 == 0: 0
(flags & 2) == 0: 0`,
      prompt: '$ gcc -Wall precedence.c -o precedence && ./precedence',
    },
    {
      type: 'quiz',
      question: 'Чему равно выражение `7 / 2` в C (оба операнда — int)?',
      options: ['3', '3.5', '4', '3.0'],
      correctIndex: 0,
      explanation:
        'При делении двух целых чисел в C результат также целый. Дробная часть отбрасывается (не округляется). Поэтому `7 / 2 = 3`, а не `3.5`.',
    },
    {
      type: 'quiz',
      question: 'Какой оператор имеет наибольший приоритет?',
      options: [
        '* (умножение)',
        '+ (сложение)',
        '() (скобки)',
        '= (присваивание)',
      ],
      correctIndex: 2,
      explanation:
        'Скобки `()` имеют наивысший приоритет. Именно поэтому они используются для явного задания порядка вычислений. Умножение имеет более высокий приоритет, чем сложение, а присваивание — один из самых низких приоритетов.',
    },
  ],
} satisfies Chapter
